{"topicSections":[{"identifiers":["doc:\/\/Digest\/documentation\/Digest\/MessageDigest","doc:\/\/Digest\/documentation\/Digest\/MT"],"title":"Classes"},{"identifiers":["doc:\/\/Digest\/documentation\/Digest\/Base64","doc:\/\/Digest\/documentation\/Digest\/HMAC","doc:\/\/Digest\/documentation\/Digest\/KDF","doc:\/\/Digest\/documentation\/Digest\/SHAKE","doc:\/\/Digest\/documentation\/Digest\/XOF"],"title":"Structures"},{"identifiers":["doc:\/\/Digest\/documentation\/Digest\/Byte","doc:\/\/Digest\/documentation\/Digest\/Bytes"],"title":"Type Aliases"},{"title":"Additional Information","identifiers":["doc:\/\/Digest\/documentation\/Digest\/References"]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","text":"Overview","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"The Digest package provides the following functionality:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Base64 encoding of bytes to text strings and the reverse decoding"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Base64 PEM encoding and decoding typically used to encode and decode cryptographic keys","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Message Digest algorithms - SHA1, SHA2 and SHA3"}]}]},{"content":[{"inlineContent":[{"text":"Extendable Output Functions - SHAKE and XOF","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Hash Based Message Authentication Codes - HMAC"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Key Derivation Functions - HKDF and X963KDF"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Mask Generation Function - MGF1"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Random number generation using the Mersenne Twister algorithm","type":"text"}]}]}]},{"anchor":"Base64","level":3,"text":"Base64","type":"heading"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Base64 example"}]}],"type":"paragraph"},{"syntax":"swift","code":["import Digest","","let b: Bytes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","let b64 = Base64.encode(b)","print(b64)","print(Base64.decode(b64)!)"],"type":"codeListing"},{"inlineContent":[{"text":"giving:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["AAECAwQFBgcICQo=","[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"PEM example"}],"type":"strong"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["import Digest","","let pem =","\"\"\"","-----BEGIN PUBLIC KEY-----","MEAwEAYHKoZIzj0CAQYFK4EEAAEDLAAEA6txn7CCae0d9AiGj3Rk5m9XflTCB81oe1fKZi4F4oip","SF2u79k8TD5J","-----END PUBLIC KEY-----","\"\"\"","\/\/ pem happens to be the PEM encoding of a public key from the ´sect163k1´ elliptic curve domain","","let der = Base64.pemDecode(pem, \"PUBLIC KEY\")!","","\/\/ ´der´ is the ASN1 DER encoding of the key from which the key could be recreated","print(der)"]},{"type":"paragraph","inlineContent":[{"text":"giving:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["[48, 64, 48, 16, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 5, 43, 129, 4, 0, 1, 3, 44, 0, 4, 3, 171, 113, 159, 176, 130, 105, 237, 29, 244, 8, 134, 143, 116, 100, 230, 111, 87, 126, 84, 194, 7, 205, 104, 123, 87, 202, 102, 46, 5, 226, 136, 169, 72, 93, 174, 239, 217, 60, 76, 62, 73]"]},{"anchor":"Message-Digest","text":"Message Digest","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Message digesting is a three step operation."}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Example","type":"text"}],"type":"strong"}]},{"syntax":"swift","code":["import Digest","","\/\/ 1. create the message digest instance","let md = MessageDigest(.SHA3_224)","","\/\/ 2. feed the data to digest in one or more steps","md.update([1, 2, 3])","md.update([4, 5, 6])","","\/\/ 3. compute the digest","let digest1 = md.digest()","","\/\/ The steps can be combined","let digest2 = MessageDigest(.SHA3_224).digest([1, 2, 3, 4, 5, 6])","","print(\"digest1:\", digest1)","print(\"digest2:\", digest2)"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"giving:"}],"type":"paragraph"},{"syntax":"swift","code":["digest1: [62, 55, 233, 98, 97, 184, 219, 20, 116, 115, 238, 1, 51, 166, 35, 107, 203, 162, 84, 97, 158, 122, 189, 59, 178, 19, 16, 201]","digest2: [62, 55, 233, 98, 97, 184, 219, 20, 116, 115, 238, 1, 51, 166, 35, 107, 203, 162, 84, 97, 158, 122, 189, 59, 178, 19, 16, 201]"],"type":"codeListing"},{"type":"heading","anchor":"SHAKE-and-XOF","text":"SHAKE and XOF","level":3},{"inlineContent":[{"type":"reference","identifier":"doc:\/\/Digest\/documentation\/Digest\/SHAKE","isActive":true},{"text":" and ","type":"text"},{"type":"reference","identifier":"doc:\/\/Digest\/documentation\/Digest\/XOF","isActive":true},{"type":"text","text":" are extendable output functions which can generate output of any desired length based on a given seed."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"SHAKE 128 example","type":"text"}]}]},{"type":"codeListing","syntax":"swift","code":["import Digest","","let shake = SHAKE(.SHAKE128)","shake.update([1, 2, 3])","print(shake.digest(25))"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"giving:"}]},{"type":"codeListing","syntax":"swift","code":["[218, 239, 167, 7, 93, 32, 41, 187, 214, 105, 12, 86, 166, 83, 123, 154, 218, 108, 92, 47, 146, 196, 24, 130, 197]"]},{"inlineContent":[{"type":"text","text":"If you know you need 25 bytes of output, you must request them all at once,"},{"text":" ","type":"text"},{"type":"codeVoice","code":"digest(12)"},{"text":" followed by ","type":"text"},{"code":"digest(13)","type":"codeVoice"},{"text":" won’t work, because the ","type":"text"},{"code":"digest","type":"codeVoice"},{"type":"text","text":" method resets "},{"type":"codeVoice","code":"shake"},{"type":"text","text":" to its original state."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"XOF 128 example","type":"text"}]}]},{"syntax":"swift","type":"codeListing","code":["import Digest","","let xof = XOF(.XOF128, [1, 2, 3])","var z: Bytes = []","for _ in 0 ..< 25 {","    z += xof.read(1)","}","print(z)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"giving:"}]},{"code":["[218, 239, 167, 7, 93, 32, 41, 187, 214, 105, 12, 86, 166, 83, 123, 154, 218, 108, 92, 47, 146, 196, 24, 130, 197]"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"XOF is similar to SHAKE, but as the examples show, the XOF "},{"type":"codeVoice","code":"read"},{"type":"text","text":" method can be called many times to accumulate the total amount of output."},{"type":"text","text":" "},{"type":"text","text":"XOF has no "},{"type":"codeVoice","code":"update"},{"text":" method, the initial seed must be supplied in the constructor.","type":"text"}]},{"text":"Message Authentication Codes","level":3,"type":"heading","anchor":"Message-Authentication-Codes"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using "},{"type":"reference","identifier":"doc:\/\/Digest\/documentation\/Digest\/HMAC","isActive":true},{"text":" to generate a message authentication code is a three step operation.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Example"}]}]},{"type":"codeListing","syntax":"swift","code":["import Digest","","\/\/ 1. create the HMAC instance with a specified message digest and secret key","let hmac = HMAC(.SHA2_256, [1, 2, 3, 4, 5, 6])","","\/\/ 2. update the HMAC instance with the text to compute the code for","hmac.update([1, 2, 3])","","\/\/ 3. compute the code","let code = hmac.compute()","print(code)"]},{"inlineContent":[{"type":"text","text":"giving:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["[165, 171, 8, 206, 249, 140, 216, 179, 11, 30, 187, 136, 116, 132, 141, 34, 66, 169, 175, 107, 27, 31, 84, 190, 108, 60, 61, 222, 233, 97, 15, 247]"]},{"anchor":"Key-Derivation-Functions","level":3,"type":"heading","text":"Key Derivation Functions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A key derivation function generates a symmetric key from a shared secret. There are two key derivation functions:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"HKDF as specified in [RFC 5859]"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"X963KDF as specified in [SEC 1]."}]}]}]},{"inlineContent":[{"text":"Both are static methods in the ","type":"text"},{"type":"reference","identifier":"doc:\/\/Digest\/documentation\/Digest\/KDF","isActive":true},{"type":"text","text":" structure."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Example"}],"type":"strong"}]},{"type":"codeListing","syntax":"swift","code":["import Digest","","let key1 = KDF.HKDF(.SHA2_224, [1, 2, 3, 4, 5, 6, 7, 8], 12, [1, 2, 3], [])","print(\"HKDF key   \", key1)","","let key2 = KDF.X963KDF(.SHA2_224, [1, 2, 3, 4, 5, 6, 7, 8], 12, [1, 2, 3])","print(\"X963KDF key\", key2)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"giving:"}]},{"type":"codeListing","code":["HKDF key    [209, 96, 93, 84, 150, 249, 149, 185, 105, 184, 47, 210]","X963KDF key [110, 88, 12, 176, 49, 119, 151, 82, 163, 233, 226, 9]"],"syntax":"swift"},{"anchor":"Mask-Generation-Function","level":3,"text":"Mask Generation Function","type":"heading"},{"inlineContent":[{"text":"The mask generation function MGF1 as specified in [RFC 8017], is a static method in the ","type":"text"},{"type":"reference","identifier":"doc:\/\/Digest\/documentation\/Digest\/KDF","isActive":true},{"type":"text","text":" structure."},{"text":"\n","type":"text"},{"type":"text","text":"It generates a mask of a specified size from a specified message digest and seed."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Example"}],"type":"strong"}]},{"syntax":"swift","code":["import Digest","","let mask = KDF.MGF1(.SHA1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 12)","print(mask)"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"giving:"}]},{"code":["[224, 166, 61, 124, 140, 77, 129, 205, 28, 5, 103, 191]"],"type":"codeListing","syntax":"swift"},{"anchor":"Random-Numbers","type":"heading","text":"Random Numbers","level":3},{"type":"paragraph","inlineContent":[{"text":"The MT class generates random numbers. There are two MT versions:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"One that uses the 32 bit Mersenne Twister algorithm","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"One that uses the 64 bit Mersenne Twister algorithm"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"MT conforms to the "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":" protocol. It generates:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Random bits","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Random integers in a specified open or closed interval"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Random unsigned integers in a specified open or closed interval"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Random floating point values in a specified open or closed interval"}],"type":"paragraph"}]}]},{"inlineContent":[{"text":"A generator instance must be instantiated either with a randomly generated seed value or with a specified seed or seed array.","type":"text"},{"text":" ","type":"text"},{"text":"The sequence of generated numbers is deterministic and depends solely on the initial seed.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The internal state of a generator instance can be saved with the "},{"code":"getState","type":"codeVoice"},{"text":" method and reinstated later with the ","type":"text"},{"type":"codeVoice","code":"setState"},{"text":" method.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"text":"Example 1","type":"text"}],"type":"strong"}],"type":"paragraph"},{"code":["import Digest","","\/\/ 32 bit version, randomly generated seed","let mt32 = MT(kind: .MT32)","","let theState = mt32.getState()","for _ in 0 ..< 3 {","  print(mt32.randomInt(in: 0 ..< 100))","}","mt32.setState(state: theState)","print(\"After reinstate\")","for _ in 0 ..< 3 {","  print(mt32.randomInt(in: 0 ..< 100))","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"giving (for example):"}]},{"syntax":"swift","code":["24","75","33","After reinstate","24","75","33"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Example 2","type":"text"}],"type":"strong"}]},{"type":"codeListing","code":["import Digest","","\/\/ 64 bit version, seed array = [123, 456, 789]","let mt64 = MT(kind: .MT64, seed: [123, 456, 789])","","for _ in 0 ..< 10 {","    print(mt64.randomInt(in: -1000 ... 1000))","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"giving:"}]},{"code":["781","570","-403","29","-924","-368","553","-60","989","418"],"type":"codeListing","syntax":"swift"},{"name":"Important","content":[{"inlineContent":[{"type":"text","text":""},{"type":"text","text":" "},{"type":"codeVoice","code":"MT"},{"type":"text","text":" is not suitable for cryptographic applications."}],"type":"paragraph"}],"type":"aside","style":"important"},{"type":"heading","text":"Usage","anchor":"Usage","level":3},{"inlineContent":[{"type":"text","text":"To use Digest, in your project Package.swift file add a dependency like"}],"type":"paragraph"},{"type":"codeListing","code":["dependencies: [","  package(url: \"https:\/\/github.com\/leif-ibsen\/Digest\", from: \"1.8.0\"),","]"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Digest itself does not depend on other packages."}],"type":"paragraph"},{"content":[{"inlineContent":[{"text":"","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Digest requires Swift 5.0. It also requires that the "},{"code":"Int","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"UInt"},{"text":" types be 64 bit types.","type":"text"}],"type":"paragraph"}],"type":"aside","name":"Important","style":"important"}]}],"kind":"symbol","sections":[],"hierarchy":{"paths":[[]]},"metadata":{"modules":[{"name":"Digest"}],"title":"Digest","symbolKind":"module","role":"collection","externalID":"Digest","roleHeading":"Framework"},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/Digest\/documentation\/Digest"},"abstract":[{"type":"text","text":"Digest and random number utilities"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/digest"]}],"references":{"doc://Digest/documentation/Digest/XOF":{"type":"topic","title":"XOF","kind":"symbol","navigatorTitle":[{"text":"XOF","kind":"identifier"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"XOF","kind":"identifier"}],"url":"\/documentation\/digest\/xof","identifier":"doc:\/\/Digest\/documentation\/Digest\/XOF","abstract":[{"text":"The XOF structure","type":"text"}],"role":"symbol"},"doc://Digest/documentation/Digest/HMAC":{"type":"topic","title":"HMAC","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"HMAC"}],"url":"\/documentation\/digest\/hmac","abstract":[{"type":"text","text":"The HMAC structure"}],"identifier":"doc:\/\/Digest\/documentation\/Digest\/HMAC","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"HMAC"}],"kind":"symbol"},"doc://Digest/documentation/Digest":{"identifier":"doc:\/\/Digest\/documentation\/Digest","role":"collection","kind":"symbol","abstract":[{"type":"text","text":"Digest and random number utilities"}],"type":"topic","url":"\/documentation\/digest","title":"Digest"},"doc://Digest/documentation/Digest/Base64":{"identifier":"doc:\/\/Digest\/documentation\/Digest\/Base64","type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Base64"}],"role":"symbol","abstract":[{"type":"text","text":"The Base64 structure"}],"kind":"symbol","title":"Base64","url":"\/documentation\/digest\/base64","navigatorTitle":[{"text":"Base64","kind":"identifier"}]},"doc://Digest/documentation/Digest/KDF":{"type":"topic","title":"KDF","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"KDF"}],"url":"\/documentation\/digest\/kdf","abstract":[{"type":"text","text":"The KDF structure"}],"identifier":"doc:\/\/Digest\/documentation\/Digest\/KDF","role":"symbol","navigatorTitle":[{"text":"KDF","kind":"identifier"}],"kind":"symbol"},"doc://Digest/documentation/Digest/References":{"type":"topic","title":"References","url":"\/documentation\/digest\/references","abstract":[{"text":"Algorithms from the following documents have been used in the implementation","type":"text"}],"identifier":"doc:\/\/Digest\/documentation\/Digest\/References","role":"article","kind":"article"},"doc://Digest/documentation/Digest/MT":{"title":"MT","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"MT"}],"type":"topic","abstract":[{"type":"text","text":"The Mersenne Twister class"}],"navigatorTitle":[{"text":"MT","kind":"identifier"}],"identifier":"doc:\/\/Digest\/documentation\/Digest\/MT","kind":"symbol","url":"\/documentation\/digest\/mt","role":"symbol"},"doc://Digest/documentation/Digest/Bytes":{"kind":"symbol","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"text":"Bytes","kind":"identifier"}],"abstract":[{"type":"text","text":"Array of unsigned 8 bit values"}],"role":"symbol","navigatorTitle":[{"text":"Bytes","kind":"identifier"}],"identifier":"doc:\/\/Digest\/documentation\/Digest\/Bytes","title":"Bytes","type":"topic","url":"\/documentation\/digest\/bytes"},"doc://Digest/documentation/Digest/SHAKE":{"type":"topic","title":"SHAKE","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"SHAKE"}],"url":"\/documentation\/digest\/shake","abstract":[{"text":"The SHAKE structure","type":"text"}],"identifier":"doc:\/\/Digest\/documentation\/Digest\/SHAKE","role":"symbol","navigatorTitle":[{"text":"SHAKE","kind":"identifier"}],"kind":"symbol"},"doc://Digest/documentation/Digest/Byte":{"type":"topic","title":"Byte","fragments":[{"text":"typealias","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Byte"}],"url":"\/documentation\/digest\/byte","abstract":[{"type":"text","text":"Unsigned 8 bit value"}],"identifier":"doc:\/\/Digest\/documentation\/Digest\/Byte","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Byte"}],"kind":"symbol"},"doc://Digest/documentation/Digest/MessageDigest":{"navigatorTitle":[{"text":"MessageDigest","kind":"identifier"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"MessageDigest","kind":"identifier"}],"role":"symbol","abstract":[{"type":"text","text":"The MessageDigest class"}],"kind":"symbol","identifier":"doc:\/\/Digest\/documentation\/Digest\/MessageDigest","title":"MessageDigest","url":"\/documentation\/digest\/messagedigest","type":"topic"}}}